ddd# DB/week1
1. [데이터베이스](#데이터베이스)
2. [관계대수와 SQL](#관계대수와-SQL)
3. [데이터베이스 설계와 ER모델](#데이터베이스-설계와-ER모델)
4. [물리적 데이터베이스 설계](#물리적-데이터베이스-설계)
5. [릴레이션 정규화](#릴레이션-정규화)
6. [트랜잭션](#트랜잭션)
7. [NoSQL](#NoSQL)
8. [ETC (안해도 됨)](#ETC-안해도-됨)

&nbsp;
## 데이터베이스
### 1. 데이터베이스와 파일시스템

- 데이터 베이스 정의
    
    데이터베이스는 여러 사람들에 의해 통합하여 관리되는 데이터의 집합입니다. 일상 대부분의 정보가 이 데이터베이스에 저장되고 관리되는데 가까운 예로 카카오톡 메시지, 대중교통 결제 정보 등이 모두 데이터베이스에 기록됩니다.

    + 사용 이유

        프로그램을 만들다보면 외부에서 입력되는 데이터나, 연산에 필요한 데이터와 같이 필연적으로 많은 데이터들이 생성되어지는데, 프로그램을 종료하고 나서도 그 데이터들을 유지하기 위해 데이터베이스에 넣고 보관합니다.
    
    + 특성

        1. 실시간 접근성 : 사용자의 요구(Query)를 실시간 처리 및 응답할 수 있습니다.
        2. 계속적인 변화 :  정확한 값을 유지하기 위해 데이터를 지속적으로 갱신할 수 있습니다.
        3. 동시 공유성 : 사용자마다 서로 다른 목적으로 사용하기 때문에 여러 사용자가 동일한 데이터에 동시에 접근하거나 이용할 수 있습니다.
        4. 내용 참조
         : 저장한 데이터 레코드의 위치나 주소가 아닌, 사용자가 요구하는 데이터 값에 따라 참조할 수 있어야 합니다.
        
    + 정의
        1. 통합된 데이터(Integrated Data): 자료의 중복을 배제한 데이터의 모임입니다.
        2. 저장된 데이터(Stored Data): 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료입니다.
        3. 운영 데이터(Operational Data): 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안 될 반드시 필요한 자료입니다.
        4. 공용 데이터(Shared Data): 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료입니다.

    + 장점

        1. 사용자에게 보다 나은 서비스와 다양한 도구를 제공합니다.
            - 데이터베이스에 데이터를 통합시켜 관리하므로 사용자가 데이터를 관리하기 쉬우며, 데이터베이스 시스템을 잘 모르는 사용자들도 질의어를 통해 보다 용이하게 데이터에 접근할 수 있습니다.
        2. 표준화를 시행하기가 용이합니다.
            - 데이터베이스에 대한 모든 접근이 DBMS를 통하기 때문에
        3. 다양한 요구 사항에 대해 우선순위를 매기고, 순서를 조절할 수 있습니다.
    
    + 쿼리 문법의 세 종류

        - 데이터 정의 언어(DDL) : 계형 데이터베이스의 구조를 정의하는 언어로, 쌍, 속성, 관계 인덱스 파일 위치와 같은 데이터베이스 고유의 특성을 포함합니다. ex) CREATE, ALTER, DROP, RENAME,TRUNCATE
        - 데이터 조작 언어 (DML) : 데이터베이스의 검색 및 업데이트 등 데이터 조작을 위해 사용합니다. ex) SELECT, INSERT, UPDATE, DELETE
        - 데이터 제어 언어 (DCL) : 데이터에 대한 액세스를 제어하기 위한 데이터베이스 언어입니다. GRANT, REVOKE와 같은 명령어를 사용해 권한을 주거나 회수합니다.

    + DB 용어

        - 식별자 : 관계형 데이터베이스에서 각각의 집합체를 구분할 수 있는 논리적인 개념입니다.
            - 유일성 : 하나의 릴레이션에서 모든 행은 서로 다른 키 값을 가져야 합니다.
            - 최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성해야 합니다.
        - 튜플 : 테이블에서 행을 의미합니다. 레코드(Record)라고도 불립니다.
            - 릴레이션에서의 중복 허용하지 않습니다.
            - 튜플의 수는 카디날리티(Cardinality)라고 합니다.
        - 어트리뷰트 : 테이블에서 열을 의미합니다. 칼럼(Columm)이라고도 불립니다.
            - 어트리뷰트의 수는 디그리(Degree)라고 합니다.

- 파일시스템 정의

    파일 시스템은 파일을 저장 장치에 저장하고 사용하기 위한 일종의 규칙이나 체계를 뜻합니다.

    + 단점

        단점을 설명하기 전에 파일 시스템에서는 파일에 접근하는 방식에 대해 말씀드리겠습니다. 이 파일 접근 방식은 응용 프로그램 내에 표현되어 있어서 응용 프로그램과 데이터 간의 의존관계가 존재하게 되어 데이터의 구조나 접근 방법이 변경되면 기존의 프로그램과 데이터를 함께 변경해야만 합니다.

        데이터 독립성이 없어서 유지보수 비용이 크며 무결성 제약조건을 명시하려면 프로그래머가 직접 프로그래밍 언어를 사용해 하나하나 표현해야하는 어려움이 있습니다.

        이외에도 SQL과 같은 쉬운 질의어가 제공되지 않아 중복 데이터 변경 시 데이터 간 불일치가 발생할 수 있으며, 파일 단위로만 권한을 부여할 수 있어서 세밀한 접근 제어와 같은 보안 기능이 미흡합니다. 또한 응용 프로그램에서 파일의 데이터를 수정하는 도중 강제로 파일이 닫힐 경우 회복할 수 있는 기능이 없습니다.

- 데이터베이스 vs 파일시스템

    + 데이터(정보) 공유

        - 파일 처리 시스템의 경우 각각의 응용 프로그램이 자신의 데이터를 파일 형태로 별도로 관리하기 때문에 자료의 중복이 발생할 수 있습니다. 반면 데이터베이스는 데이터를 통합해 모든 부서와 관련된 사람들이 공유하는 것이기 때문에 자료의 독립성이 보장된다는 차이가 있습니다.
        
        - DBMS 주요 기능
        
            - 여러 사용자에세 단일 데이터베이스에 대한 동시 액세스 부여
            - 보안 규칙을 수립하고 사용자 액세스 권한을 관리
            - 데이터를 정기적으로 백업하고 침해 발생 시 데이터를 신속하게 복구
            - 데이터베이스 규칙과 표준을 설정하여 데이터 무결성 보호
            - 가용 데이터에 대한 "사전적" 정의와 설명을 제공

        - 중복의 문제점

        1. 일관성 : 여러 개의 데이터가 모두 하나의 사실만을 나타낸다면 논리적으로 모두 동일하지만 데이터의 중복이 있을 경우 그 동일성을 유지하기 어려워지기 때문입니다.
        2. 보안성 : 모두 똑같은 수준의 보안을 유지하기 어렵고, 인가되지 않은 변경에 대한 데이터 무결성을 유지하기 어렵습니다.
        3. 경제성 : 추가적인 저장 공간이 필요해 비용이 늘어나게 됩니다.
        4. 효율성 : 공동 데이터 파일에 대해 한 프로그램이 이를 사용하는 동안에는 다른 응용 프로그램이 그 데이터 파일에 접근할 수 없습니다.

    + 규모와 비용

    데이터베이스 시스템의 소프트웨어의 규모가 크고 복잡해서 파일방식보다 많은 하드웨어 자원을 필요로 하므로 추가적인 하드웨어 구입 비용이 들 수 있고, DBMS 자체의 구입 비용과 유지, 보수 비용도 상당히 비싼 편입니다.

    상황에 따라서 파일 시스템을 사용하는 것이 더 좋은 경우도 있습니다. 응용이 단순하고, 엄격한 실시간 처리 요구 사항이 있을 경우 혹은 데이터에 대한 다수 사용자의 접근이 필요로 하지 않는 경우

### 2. 데이터베이스의 특징과 제약 조건

- 특징

    1. 실시간 접근성(Real-Time Accessibility) : 수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 합니다.
    2. 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적이다. 즉 새로운 데이터의 삽입(Insert),삭제(Delete),갱신(Update)로 항상 최신의 데이터를 유지합니다.
    3. 동시공용(Concurrent Sharing): 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 합니다.
    4. 내용에 의한 참조(Content Reference): 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터를 찾을 수 있습니다.

- 구성요소

    1. 데이터베이스
    2. 스키마
    3. DBMS(데이터베이스 관리 시스템)
    4. 데이터베이스 언어
    5. 데이터베이스 컴퓨터
    6. 데이터베이스 사용자

- 데이터 베이스의 제약조건

    제약 조건이란 데이터의 무결성을 지키기위해 입력받은 데이터에 대한 제한을 두는 것을 의미합니다.

    + MySql에서 제공하는 제약조건

        - PRIMARY KEY 제약조건

            "기본키에 값은 중복되지 않으며 NULL 일 수 없다"
            테이블에 존재하는 많은행의 데이터를 구분할 수 있는 식별자를 기본키라고 합니다.
            하나의 열에만 기본키를 설정 할 수 있으며, 두 개의 열을 합쳐서 기본키를 설정 할 수도 있습니다. 대부분의 테이블은 기본키를 갖는 열을 가져야 합니다.

        - FOREIGN KEY 제약조건

            "외래 키 테이블이 참조하는 테이블의 열은 반드시 primary key 이거나 unique 제약조건이 설정되어 있어야한다."
            외래키 제약조건은 두 테이블 사이의 관계를 선언함으로써 데이터의 무결성을 보장해 주는 역할을 합니다. 외래키 관계를 설정하면 하나의 테이블이 다른 테이블에 의존하게 됩니다. ex) 부서 번호

        - UNIQUE 제약조건

            "중복되지 않는 유일한 값"을 입력해야 하는 조건입나다. PRIMARY KEY 제약조건과 비슷하지만 NULL값을 허용한다는 점에서 차이가 있습니다. ex) 이메일

        - CHECK 제약조건

            입력되는 데이터를 점검하는 기능이다. 나이값에 마이너스값이 들어올 수 없게 한다든지, 출생년도가 1900년 이후여야 한다든지, 등등 조건을 지정합니다.

        - DEFAULT 제약조건
        
            DEFAULT 는 값을 입력하지 않을 경우 자동으로 입력되는 기본 값입니다.


## 관계대수와 SQL

- 관계대수

    어떻게 질의를 수행할 것인가를 명시하는 절차적 언어이다.
    상용 관계 DBMS 들에서 널리 사용되는 SQL의 이론적인 기초이고, SQL을 구현하고 최적화하기 위해 DBMS의 내부 언어로서도 사용된다.

- 관계 대수의 한계
    - 산술 연산을 할 수 없습니다. (=집단 함수를 지원하지 않음) -> 그래서 집단 함수, 그룹화, 외부 조인이 추가됨.
        - 집단 함수 : 
    - 정렬을 나타낼 수 없음
    - 데이터 베이스를 수정할 수 없음
    - 프로젝션 연산의 결과에 중복된 츄플을 나타내야할 때가 있는데 이를 명시하지 못함.

### 3. SELECT
- 정의

    시그마 기호와 조건, 그래고 피연산자로 이루어진 단항 연산자이다.

- 목적(역할)

    한 릴레이션에서 셀렉션 조건을 만족하는 튜플들의 부분 집합을 생성한다.

- 특징
    - 조건문에는 속성 간의 비교 연산자(= < > 등등)가 사용된다.
    - 조건문이 여러 개인 경우 ∨(or) 또는 ∧(and)가 사용된다.

### 4. SQL

- 정의

    구조화된 질의어라는 뜻으로, 관계형 데이터베이스의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이다.

- 특징
    - 데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
        - 스키마에 따라 ?  데이터는 레코드의 형태로 테이블에 저장되어 있음. 각 테이블마다 필드의 이름과 데이터 유형으로 명확하게 정의되어 있기 때문에 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없음
    - 데이터는 관계를 통해 여러 테이블에 분산됩니다.
        - 관계 ?  데이터의 중복을 피하기 위해

- 장단점

    정해진 스키마를 따라야 한다는 점이 SQL의 장점이기도 하고 단점이기도 하다.

    하나의 테이블에선 하나의 데이터만을 중복 없이 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 반면,

    다른 구조의 데이터를 같은 컬렉션에 추가할 수 없어 확장성이 좋지 않다는 단점이 있다.

### 5. Join
- 정의

    한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것이다.

- 특징

    조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.
    
- 조인의 종류

    + 내부 조인

        조인 구문에 기반한 2개의 테이블(A, B)의 컬럼 값을 결합하여 새로운 결과 테이블을 생성하는 결합 방식입니다. 명시적 조인 표현(explicit)과 암시적 조인 표현(implicit) 등의 조인식 구문으로 표현할 수 있다.

        - 명시적 조인

            테이블에 조인을 하라는 것을 지정하기 위해 JOIN 키워드를 사용하며, 그리고 나서  ON 키워드를 조인에 대한 구문을 지정하는데 사용한다.

        - 암시적 조인

            SELECT 구문의 FROM 절에서 테이블을 분리하는 컴마를 사용해서 단순히 조인을 위한 여러 테이블을 나열하기만 한다.

    + 외부 조인

        조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용하여 효과적으로 결과 집합을 생성할 수 있습니다.

    + 셀프 조인

        한 테이블에서 자기 자신에 조인을 시키는 것입니다.

- 주의할 점

    + SQL 문장의 의미를 제대로 파악

        SQL을 어떻게 작성하느냐에 따라 성능이 크게 좌우된다. 어떤 질의를 수행할 것인지를 명확하게 정의한 후, 비효율을 제거하여 최적의 SQL을 작성해야 한다.

    + 명확한 조인 조건 제공

        조인 조건을 명확하게 제공하지 않을 경우, 의도치 않게 CROSS JOIN(Cartesian Product)이 수행될 수 있다.

- 조인을 사용할 때 고려사항

    + 조인할 대상의 집합을 최소화

        집합을 최소화할 방법이 있으면, 조건을 먼저 적용하여 관계를 맺을 집합을 최소화한 후, 조인을 맺는 것이 효율적이다.

    + 효과적인 인덱스의 활용

        인덱스를 활용하면, 조인 연산의 비용을 극적으로 낮출 수 있다.

### 6. NULL

    데이터베이스에서 아직 알려지지 않았거나, 모르는 값으로서 "해당 없음" 등의 이유로 정보 부재를 나타내기 위해 사용하는, 이론적으로 아무것도 없는 특수한 데이터

### 7. Trigger와 Procedure
- Trigger

    - 정의

         DB 시스템에서 삽입, 갱신, 삭제 등 이벤트가 발생할 때마다 자동 수행되는 절차형 SQL이다. 사전적 의미로 '방아쇠'를 뜻함다. 당기면 '자동'으로 총알이 나가듯, 트리거는 테이블에 무슨 일이 일어나면 '자동'으로 실행된다.
         
    - 목적

        무결성 유지, 로그 메시지 출력 등의 목적으로 사용한다.

    - 특징

        - 트리거 문에는 DCL(권한 등)을 사용할 수 없음
        - DDL, DML 사용할 수 있음

- Procedure

    - 정의
    
         절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어이며 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행한다.

    - 목적

        시스템의 일일 마감 작업, 일괄 작업 등과 같은 특정 기능을 수행하기 위함. 스토어드(Stored) 프로시저라고도 불린다.

- Trigger와 Procedure

    - 공통점
        - 데이터베이스에 저장하며 절차형 SQL이다.
        - 구성 시 DECLARE, BEGIN, END를 필수로 가져야 한다.
    - 차이점
        - 목적이 다르다.
            - 프로시저는 EXECUTE 명령어로 실행, 트리거는 생성 후 자동실행 
        - 트리거는 COMMIT, ROLLBACK와 같은 데이터 제어어를 사용할 수 없음. 프로시저는 가능

## 데이터베이스 설계와 ER모델
### 8. 데이터베이스 설계의 과정
크게 다섯가지분로 류 : 요구사항 분석 / 개념적 설계 / 논리적 설계 / 물리적 설계 / 구현

1. 요구사항 분석
    - 데이터베이스의 사용 용도를 파악하기 위한 단계.
    - 사용자에게 필요한 데이터의 종류와 처리 방법같은 다양한 요구 사항을 수집하고 분석하여 요구 사항 명세서로 작성하는 것이 주요 작업
    - 사용이유
        - 사용자의 요구 사항은 이후의 설계 단계에서 중요하게 사용되며 데이터베이스의 품질의 중요한 기준

2. 개념적 설계
    - 1단계인 요구 사항 분석단계의 요구 사항 명세서를 가지고 사용자의 개념적 데이터 모델을 이용해 표현한다. 
    - 요구 사항 명세서를 개념적 데이터 모델로 변환하는 작업을 개념적 모델링이라고 하는데, E-R 다이어그램과 같이 개념적 데이터 모델로 표현한 결과물을 개념적 구조 또는 개념적 스키마라고 한다.

3. 논리적 설계
    - 개념적 설계 단계에서 생성한 개념적 구조를 기반으로 개발에 사용되는 DBMS에 적합한 논리적 구조를 설계한다.
    - DBMS의 종류에 따라 네트워크 데이터 모델, 관계 데이터 모델, 계층 데이터 모델, 객체 지향 데이터 모델 등을 논리적 데이터 모델로 사용할 수 있다.
    - 2단계인 논리적 설계 단계에서 E-R 다이어그램을 3단계 논리적 설계 단계의 릴레이션 스키마로 변환하는 것을 논리적 모델링 또는 데이터 모델링이라고 하며, 논리적 데이터 모델로 표현된 결과물을 논리적 구조 또는 논리적 스키마라고 한다.

4. 물리적 설계
    - 3단계 논리적 설계 단계에서 설계된 논리적 구조를 바탕으로 물리적 구조를 설계한다.
    - 데이터베이스 파일의 저장 구조 및 액세스 경로, 인덱스 구조, 레코드 크기, 순서, 경로 등을 결정한다. 이는 반응시간과 공간활용도, 트랜잭션 처리량을 고려하며 설계해야 한다.
    - 물리적 설계의 결과물인 물리적 구조를 내부 스키마 또는 물리적 스키마라고 한다.
    - 목적
        -  응답 시간을 최소화하고 저장 공간을 효율적으로 활용하며, 데이터 처리 능력을 향상시키며 설계하는 것

5. 구현
    - 이전 설계 단계의 결과물들을 기반으로 DBMS에서 SQL로 작성한 명령문을 실행하며 데이터베이스를 실제로 생성한다. 
    - 특정 DBMS에서 데이터베이스 스키마를 만들고 데이터를 입력하며, 응용 프로그램에서 사용하기 위한 트랜잭션 또한 생성한다.

### 9. 스키마, 엔티티, 릴레이션, 인스턴스
데이터 모델과 관련된 용어.
- 데이터 모델

    데이터의 관계, 접근과 그 흐름에 필요한 처리 과정에 관한 추상화된 모형

- 스키마
    - 정의
        - 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
            - 구조 
                - 엔티티(개체), 애트리뷰트(속성), 릴레이션십(관계)
            - 메타데이터 
                - 여러 의미. '속성 정보'라 불리는데, '데이터에 관한 구조화된 데이터', '다른 데이터를 설명해 주는 데이터'라고도 함.

    - 역할 및 사용 이유
        - 데이터 중복 감소 또는 제거
        - 데이터 불일치 및 부정확성 방지
        - 데이터 정확성과 무결성 보장
        - 신속한 데이터 조회, 검색 및 분석 지원
    
    - 사용자의 관점에 따라 외부 스키마/ 개념 스키마/ 내부 스키마
        - 외부 스키마
            - 사용자 뷰. 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
            - 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며, 하나의 외부 스키마를 여러 개의 응용 프로그램이나 사용자가 공용할 수 있음.

        - 개념 스키마
            - 전체적인 뷰. 모든 응용 시스템과 사용자가 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스로 하나만 존재
            - 데이터베이스의 전체적인 논리적 구조로 데이터베이스 관리자에 의해 구성됨.
            - 역할
                - 개체간의 관계와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
        - 내부 스키마
            - 저장 스키마. 물리적 저장 장치 입장에서 본 데이터베이스의 구조
            - 내부레코드 형식, 인덱스 유무, 데이터 표현 방법 등을 기술함.

- 엔티티

    - 정의

        - 업무상 관리가 필요한 것.
        - 사람, 장소, 물건, 사건, 개념 등과 같은 명사.
        - ex) 학교에서 학생이라는 엔티티가 존재 가정. 엔터티는 인스턴스의 집합으로 나타나게 됨. 수학, 영어, 국어와 같은 인스턴스 집합이 과목이라는 애트리뷰트로 학생 엔터티에 포함되는 것이다.

    - 특징

        - 반드시 엔티티가 사용되는 곳의 업무에서 필요하고 관리하고자 하는 정보여야 한다.
        - 엔티티가 포함하는 인스턴스에 대해 유일한 식별자로 식별 가능해야 한다.
        - 반드시 속성을 지녀야 한다.
        - 타 엔티티와 최소 한 개 이상의 관계가 있어야 한다.

    - 분류

        1. 실체 유형(유무형)에 따른 분류
            - 유형 엔티티 : 물리적인 형태가 존재하는 엔티티로 안정적이고 지속적으로 활용되는 엔티티. ex) 학생, 교수, 사원
            - 개념 엔티티 : 물리적인 형태는 존재하지 않고 관리해야 할 개념적인 정보로 구분되는 엔티티.  ex) 조직, 서비스 상품
            - 사건 엔티티 : 업무를 수행함에 따라 생성되는 엔티티  ex) 주문, 조회수
        2. 발생 시점에 따른 분류   
            - 기본, 키 엔티티 : 해당 업무에 원래 존재하는 엔티티. 다른 엔티티와의 관계에 의해 발생되지 않고 독립적으로 존재하며 다른 엔티티의 부모 역할을 함. ex) 고객, 상품
            - 중심 엔티티 : 업무의 중심적인 역할을 하는 엔티티. 기본 엔티티로부터 생성되며 일반적으로 데이터양이 많고 다른 엔티티와의 관계를 통해 행위 엔티티를 생성함. ex) 주문, 취소, 체결
            - 행위 엔티티 : 주로 두 개 이상의 부모 엔티티로부터 발생되는 엔티티. 엔티티의 내용이 자주 바뀌거나 데이터의 양이 증감함. ex) 주문 목록, 취소 사유, 사원 변경 이력
    - 도메인

        엔티티의 속성들이 가질 수 있는 값들의 집합으로써 대부분의 DBMS에서 도메인이란 속성에 대응하는 컬럼에 대한 데이터 타입과 길이를 의미한다. 정의된 도메인 명은 일반적인 데이터 타입처럼 사용할 수 있다.

        두 속성의 도메인이 같다 == 두 속성의 데이터 타입과 길이가 같다

- 릴레이션

    - 정의
        - 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본단위. 표의 형태로 표현했다 해서 테이블이라고도 부름. 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
        - 애트리뷰트(=속성, 필드, 열), 튜플(=레코드, 행), 도메인, 널
            - 도메인 : 이름, 전화번호, 주소, 생일과 같이 각 필드가 가질 수 있는 모든 값들의 집합
            - 널 : 특정 필드에 대한 값을 알지 못하거나, 아직 정해지지 않아 입력하지 못한 경우. 0이나 공백 문자와는 다름
    - 역할
        - 
    - 특징
        - 한 릴레이션에는 똑같은 튜플이 포함될 수 없음. 
        - 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함
        - 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 함
        - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장

- 인스턴스
    - 정의
        - 정의된 스키마에 따라 데이터베이스에 실제로 저장된 값.
        - ex) 개인정보 엔티티 > 나이 애트리뷰트 > 1~100 도메인 > 3개의 튜플 각각 3살 8살 10살 > 값이 저장된 튜플의 집합이 인스턴스

### 10. 엔티티, 애트리뷰트, 관계
- 엔티티
    - 속성을 포함해야 함(식별자만 있으면 의미없음)
    - 관계가 존재해야함

- 애트리뷰트(속성)
    - 엔티티, 인스턴스, 속성, 속성값의 관계
        - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합.
        - 한 개의 엔터티는 두 개 이상의 속성을 가짐.(식별자 외에 1개이상 필요)
        - 한 개의 속성은 한 개의 속성값을 가짐.

    - 데이터베이스를 구성하는 가장 작은 논리적 단위이며 개체의 특성을 기술한다. 
    - 속성의 수를 디그리(Degree) 또는 차수라고 한다.
    

- 관계(Relationship. 릴레이션십)
    - 인스턴스 사이의 논리적인 연관성
    - 표기법
        - 관계명(Membership) : 관계의 이름
        - 관계차수(Cardinality) : 1:1, 1:M, M:N
        - 관계선택사양(Optionality) : 필수관계(not null), 선택관계(nullable, O를 표시)
### 11. 키
- 정의

    데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 Attribute(속성)

1. 후보키(Candidate Key)

    - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분집합
    - 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다.
    - 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야한다.

2. 기본키 (Primary Key)

    - 후보키 중에서 선택한 주키(Main Key)
    - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
    - Null 값을 가질 수 없음 (개체 무결성의 첫번째 조건)
    - 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음 (개체 무결성의 두번째 조건)

3. 대체키 (Alternate Key)

    - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
    - 보조키라고도 함

4. 슈퍼키 (Super Key)

    - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 유일성은 만족하지만, 최소성은 만족시키지 못한다. 

5. 외래키 (Foreign Key)

    - 관계(Relation)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
    - 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용됨

- 최소성과 유일성

    - 유일성 :  하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질

        여러개의 튜플이 존재할 때 각각의 튜플을 서로 구분할 수 있어야 한다. 각각의 튜플을 유일해야 한다는 의미. 예를 들어 주민번호, 나이, 성별이라는 속성이 있을 때, 나이나 성별은 충분히 중복될 수 있는 속성. 그러나 주민번호는 모두 다르기 때문에 중복될 수 없음.
    
    - 최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질

        키를 구성하는 속성들이 진짜 각 튜플을 구분하는데 꼭 필요한 속성들로만 구성되어 있는가를 의미. 예를 들어 주민번호, 이름, 나이라는 키가 있다면, 이 세 속성이 모두 같은 사람은 없어 튜플을 구분할 수 있다. 그러나 생각해보면 이름, 나이를 빼고도 주민번호만으로 각 튜플을 유일하게 식별할 수 있음. 이때 이름, 나이를 빼면 해당 키는 최소성을 만족한다.

### 12. 뷰

- 정의

    - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블이다. 임시로 보여주기 위한 가상테이블임에도 이름을 갖고 있다는 것이 특징이다.

- 역할

    - 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.

- 특징

    - 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
    - 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
    - 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
    - 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.

- 장점

    - 논리적 데이터 독립성을 제공한다.
    - 동일 데이터에 대해 동시에 여러사용자의 상이한 응용이나 요구를 지원해 준다.
    - 사용자의 데이터관리를 간단하게 해준다.
    - 접근 제어를 통한 자동 보안이 제공된다.

- 단점

    - 독립적인 인덱스를 가질 수 없다.
    - ALTER VIEW문을 사용할 수 없다. 즉 뷰의 정의를 변경할 수 없다.
    - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

## 물리적 데이터베이스 설계
### 13. 데이터베이스와 메모리

### 14. 인덱스
- 정의
    - 데이터베이스에서 조회 및 검색을 더 빠르게 할 수 있는 자료구조
- 사용 이유
    - select문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원과 시간이 소모될 것. 이때 도움이 되는게 인덱스이다.

### 15. B Tree와 B+ Tree
DBMS에서의 인덱스 관리 방법

- B Tree
    - Balanced Tree의 한 종류로, 이진 트리를 확장하여 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.

        - Balanced Tree
            
            노드 삽입 및 삭제 시 스스로 균형을 맞춰주는 트리. 어느 경로를 가더라도 높이가 같도록 해주면 효율적으로 해줄 수 있다(O(logN). 기존 이진 트리의 문제점은 좌우 균형이 맞지 않는 것이었다.  트리가 좌우 불균형 하면 높이가 커서 검색하는데 상당히 비효율적으로 시간이 걸릴 수가 있다(O(N)).
        
        - 장점
            - 하나의 노드에 여러 자료를 배치하게 되면서 이진 트리보다 훨씬 많은 데이터를 더 효율적으로 저장소에 담을 수 있다. 

        - 특징
            - 각 노드의 자료는 정렬되어 있다.
            - 자료는 중복되지 않는다.
            - 모든 leaf node는 같은 레벨에 있다.
            - root node는 자신이 leaf node가 되지 않는 이상 적어도 2개 이상의 자식을 가진다.
            - root node가 아닌 노드들은 적어도 M/2개의 자식 노드를 가지고 있다. (최대 M개)

- B+ Tree
    - 정의
        - B-Tree는 탐색을 위해서 노드를 찾아서 이동해야 한다는 단점
        - B Tree의 확장개념으로, b-tree와 달리 모든 노드에 key, data가 있지 않으며, leaf 노드에만 key, data가 있어 같은 레벨의 leaf 노드는 연결리스트 형태로 이어져있다.
    - 장점
        - 특정 값을 찾아야 하는 상황이 된다면 leaf node에 모든 자료들이 존재하고, 그 자료들이 연결리스트로 연결되어 있으므로 탐색에 있어서 매우매우 유리
    - 특징
        - 데이터 노드의 자료는 정렬되어 있다.
        - 데이터 노드에서는 데이터가 중복되지 않는다.
        - 모든 leaf node는 같은 레벨에 있다.
        - leaf node가 아닌 node의 키값의 수는 그 노드의 서브트리수보다 하나가 적다.
        - 모든 leaf node는 연결리스트로 연결되어 있다.

- B Tree vs B+ Tree

    | 구분 | B Tree | B+ Tree|
    | --- | --- | --- |
    | 데이터 저장 | 리프 노드, 브랜치 노드 모두 데이터 저장 가능 | 오직 리프 노드에만 데이터 저장 가능 |
    | 트리의 높이 | 높음 | 낮음(한 노드 당 key를 많이 담을 수 있음) |
    | 풀 스캔 시, 검색 속도 | 모든 노드 탐색 | 리프 노드에서 선형 탐색 |
    | 링크드 리스트 | 없음 | 리프 노드끼리 링크드 리스트로 연결 |

### 16. 해시
- 정의
    - 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값이다.
- 목적
    - 특정한 배열의 인덱스나 위치나 위치를 입력하고자 하는 데이터의 값을 이용해 저장하거나 찾을 수 있다.
- 장점
    - 기존에 사용했던 자료 구조들은 탐색이나 삽입에 선형시간이 걸리기도 했던것에 비해, 해시를 이용하면 즉시 저장하거나 찾고자 하는 위치를 참조할 수 있으므로 더욱 빠른 속도로 처리할 수 있다.
- 특징
    - 무결성
        - 특정한 데이터를 이를 상징하는 더 짧은 길이의 데이터로 변환하는 행위를 의미한다.
    - 보안성
        - 기본적으로 복호화가 불가능하다는 특징이 있다. 왜냐하면 입력 데이터 집합이 출력 데이터 집합을 포함하고 있으므로, 특정한 출력 데이터를 토대로 입력 데이터를 찾을수 없기 때문이다.
    - 비둘기집 원리
        - 해시 충돌이 발생할 여지가 있다. 비둘기가 5마리일때 상자가 4개밖에 존재하지 않는다면 아무리 비둘기를 균등하게 분배해도 최소한 한 상자에는 2마리의 비둘기가 들어가게 된다.
        - 2의 128제곱 경우의 수로 표현할 수 있는 128비트 공간에 입력 값의 개수가 2의 128제곱을 넘어가면 최소한 한 쌍의 입력값은 그 결과 값이 동일할 것.
    - 해시레이트
        - 연산 처리능력을 측정하는 단위로 해시 속도를 의미한다.
        - 일반적으로 해시레이트가 높아져 연산량이 많아질 경우, 더 빠른 채굴이 이루어지기 때문에 채굴 난이도가 높아진다.

## 릴레이션 정규화
### 17. 이상현상

- 정의 
    - 이상 현상이란 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 할 때 발생할 수 있는 부작용

1. 삽입 이상
    - 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
2. 갱신 이상
    - 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 문제
3. 삭제 이상
    - 튜플을 삭제하면 꼭 필요한 데이터까지 같이 삭제되는 데이터 손실 문제



### 18. 정규화

- 정의
    - 이상 현상을 제거하기 위해서 릴레이션을 의미 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 과정이다.
    - 이때 함수적 종속성을 판단하여 정규화를 진행한다.
        - 함수적 종속성 : 속성들 간의 관련성

- 함수 종속
    - X -> Y 일 때

        "X가 Y를 함수적으로 결정한다" = "Y가 X에 함수적으로 종속되어 있다." 릴레이션 내의 모든 튜플을 대상으로 하나의  X값에 대한 Y값이 항상 하나인 경우를 의미한다.
    
    - 완전 함수 종속 :  X -> Y 일 때 속성 집합 X의 일부분에는 Y가 종속되어 있지 않는다.
    - 부분 함수 종속 : 속성 집합 X의 부분집합에도 Y가 함수적으로 종속되어 있을 때 
    - 이행적 함수 종속 : X -> Y, Y -> Z 가 있으면 논리적으로 X -> Z 가 성립된다. 이것을 Z가 X에 이행적으로 함수 종속되었다고 한다.

### 19. 역정규화

## 트랜잭션
### 20. 트랜잭션
- 정의

    데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻한다.

- 상태 변화 : SELECT, INSERTM DELETE, UPDATE와 같은 SQL을 이용해 데이터베이스에 접근하는 것

- 특징
    1. 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다
    2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
    3. 하나의 트랜잭션은 Commit되거나 Rollback된다.

- 성질
    1. 원자성 (Atomicity)
        - 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
        - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
    2. 일관성 (Consistency)
        - 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
        - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
    3. 독립성 (Isolation)
        - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
        - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
    4. 지속성 (Durability)
        - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

- 연산
    - Commit
        - 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다라는 것을 알려주기위해 사용하는 연산이다.
    - Rollback
        - 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 취소하는 연산이다.
        - Rollback시 해당 트랜잭션을 재시작하거나 폐기한다.

- 상태
    - 활동(Active) : 트랜잭션이 실행중인 상태
    - 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
    - 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
    - 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
    - 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

### 21. 트랜잭션 격리 수준
- 정의

    동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다.

- 분류 : READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE로  나뉨. 뒤로갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어질 수도 있다고 함.

- READ UNCOMMITTED(커밋되지 않은 읽기)
    - 
- READ COMMITTED(커밋된 읽기)
    - 
- REPEATABLE READ(반복 가능한 읽기)
    - 
- SERIALIZABLE(직렬화 가능)
    - 

### 22. DB Deadlocks

## NoSQL
### 23. NoSQL

### 24. CAP

### 25. NoSQL vs RDB

## ETC 안해도 됨
### 26. Connection Pool

### 27. Hint

### 28. SQL Injection

### 29. Optimizer

### 30. Replication

### 31. Partitioning

### 32. Sharding

### 33. 분산 환경과 트랜잭션

### 34. ORM
- Object-Relational Mapping 객체-관계 매핑
- 정의
    - 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다. 
    - 각 테이블 또는 구분하고자 하는 데이터 단위로 객체를 구현하고, 데이터 간의 관계를 형성

- 생성 이유
    - 객체지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용하기 때문에 객체 모델과 관계형 모델간에 불일치가 존재
    - 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결
    
- 장점
    - 객체지향적인 코드로 인해 더 직관적이고 로직에 집중할 수 있도록 도와준다
        - SQL의 절차적이고 순차적인 접근이 아닌 객체지향적인 접근으로 인해 생산성을 높여준다
        - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 줄어든다
        - 객체마다 코드를 별도로 작성하기 때문에 코드의 가독성이 높아진다
    - 재사용 및 유지보수의 편리성이 증가한다
        - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용할 수 있다
        - 매핑 정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다
    - DBMS에 대한 종속성이 줄어든다
        - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다
        
- 단점
    - 완벽한 ORM 으로만 서비스를 구현하기가 어렵다
        - 사용하기는 편하지만 설계는 매우 신중하게 해야한다
        - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있
    - 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다
        - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있
